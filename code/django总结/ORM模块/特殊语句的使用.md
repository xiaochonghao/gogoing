### select_for_update

* 返回queryset，并将需要更新的行锁定，类似于`SELECT ... FOR UPDATE`的操作。

```python
# 所有匹配的entries都会被锁定直到此次事务结束。
with transaction.atomic():
    entries = Entry.objects.select_for_update().filter(author=request.user)
```

---

### select_related

```python
from django.db import models
 
class Province(models.Model):
    name = models.CharField(max_length=10)
    def __unicode__(self):
        return self.name
 
class City(models.Model):
    name = models.CharField(max_length=5)
    province = models.ForeignKey(Province)
    def __unicode__(self):
        return self.name
```
* 传统做法

    ```python
    >>> citys = City.objects.all()
    >>> for c in citys:
    ...   print c.province
    ...
    ```
    这样会导致线性的SQL查询，如果对象数量n太多，每个对象中有k个外键字段的话，就会导致n*k+1次SQL查询。在本例中，因为有3个city对象就导致了4次SQL查询：
    ```SQL
    SELECT `QSOptimize_city`.`id`, `QSOptimize_city`.`name`, `QSOptimize_city`.`province_id`
    FROM `QSOptimize_city`;
 
    SELECT `QSOptimize_province`.`id`, `QSOptimize_province`.`name` 
    FROM `QSOptimize_province`
    WHERE `QSOptimize_province`.`id` = 1 ;
    
    SELECT `QSOptimize_province`.`id`, `QSOptimize_province`.`name` 
    FROM `QSOptimize_province`
    WHERE `QSOptimize_province`.`id` = 2 ;
    
    SELECT `QSOptimize_province`.`id`, `QSOptimize_province`.`name` 
    FROM `QSOptimize_province`
    WHERE `QSOptimize_province`.`id` = 1 ;
    ```
* select_related做法
    ```python
    >>> citys = City.objects.select_related('province').all()
    >>> for c in citys:
    ...   print c.province
    ...
    ```
    ```SQL
    SELECT `QSOptimize_city`.`id`, `QSOptimize_city`.`name`, 
    `QSOptimize_city`.`province_id`, `QSOptimize_province`.`id`, `QSOptimize_province`.`name` 
    FROM`QSOptimize_city` 
    INNER JOIN `QSOptimize_province` ON (`QSOptimize_city`.`province_id` = `QSOptimize_province`.`id`) ;
    ```
* 注意使用select_related一定要指定参数或者指定`depth`，否则默认`depth=0`，将会遍历该`model`的所有外键，知道遍历不到。